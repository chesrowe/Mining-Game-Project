<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Defines the default values for the variables the enemy children when needed(default is the wolf)
hp = 160; //the amount of Healt the enemy is going to have
dmg = 5; // The base amount of damage an enemy deals
dmgNumber = 0; // A variable used to store the id of the dmg number created when the enemy is damaged
knockBackLeft = 0; // A boolean variable used to check if the enemy is being knocked back to the left or not
knockBackRight = 0; // A boolean variable used to check if the enemy is being knocked back to the left or not 
knockTimer = 0; // A timer variable used to control how long the enemy is knockedback
moveSpeed = 0; 
facing = 'right'; // Which way the enemy is facing

hpBar = instance_create(x,y,obj_enemyHpDraw); // Creates the instance that controls  the drawing of the enemy's health bar
hpBar.enemy = 1; // A boolean variable in hpbar that checks whether the hpbar is being drawn for an enemy or a miner(in this case, it's for a enemy)
hpBar.myEnemy = id; // sets the myEnemy var in hpBar to the id of this enemy
hpBar.hp = hp; // Tells hpBar how much health the enemy has so it can draw the bar right
hpBar.hpMult = (hp/10); // A variable whos value is 1/10th of the enemy's Hp ( used to draw the hp bar proportional to the amount of hp the enemy has)
dying = 0; // A boolean var used to check if the enemy is dying or not
image_speed = .1; // sets the starting image_speed for the enemy
jumpAttack = 1; // A boolean used to check if the enemy has a jump attack or not
state = 'walking' // Sets the starting state for the enemy to walking
jumpTimer = 0; // A timer used to set how long a jump will last(counter)
jumping = 0; // A boolean used to check if the enemy is jumping or not
walkSpeed = .5; // sets the walking speed for the enemy
runSpeed = 1.5; // Sets the run speed for the enemy
nearestTarget = 0;// A var that stores the id of the nearest enemy
knockBackSpeed = 2; // the speed at which the enemy is knocked back at
curKBSpeed = 2; // The current speed of the knockback(this value is decreased as the enemey is knocked back to simulate friction)
fric = .1; // The amount of friction the enemy has when being knocked back
minerDist = 0; // Stores the distance from the enemy to the nearest miner(if one exists)
madeContact = 0; // A boolean used to check to see if the enemy has made contact with the target yet
contactTarget = 0; // if the enemy has made contact with the target, it's id is stored in this var
attack = 0; // NOT USED
attackTimer = 0; // A tiemr that counts up between each attack(basicly used to set the attack speed)
hillStart = 0;
spriteAttackingRight = spr_wolfAttackingRight; // sets the sprite for when the enemy is attacking to the right
spriteAttackingLeft = spr_wolfAttackingRight; // sets the sprite for when the enemy is attacking to the right

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Falling 
// y = y + lengthdir_y(2,70); 
//x = x + lengthdir_x(2,70); 

if (place_meeting(x,y+3,obj_groundParent)){
    falling = 0;
    if (place_meeting(x,y+3,obj_tileSurfaceFlatParent) &amp;&amp; !place_meeting(x,y,obj_tileSurfaceHillParent)){
        y = (instance_place(x,y+3,obj_tileSurfaceFlatParent).y) - 24;
    }
}else if (!hillStart){
    falling = 1;
}

//when the worker is falling 
if (falling){
    gravity = 0.2;
}else{
    gravity = 0;
    vspeed = 0;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
// Checks to see if the enemy is dying or not
if (!dying){
    //sets nearest enemy to the nearest miner
    if (instance_exists(obj_workerParent)){
        nearestTarget = instance_nearest(x,y,obj_workerParent);
        minerDist = distance_to_point(nearestTarget.x,nearestTarget.y);
    }else{
        madeContact = 0;
        contactTarget = -1;
        minerDist = 999999999999;
        nearestTarget = -1;
    }  
    //Sets the state to attack if a target is in range 
    if (minerDist &lt; 150 &amp;&amp; nearestTarget != -1){
            state = 'attacking';
    }else{
            state = 'walking';
    } 
    //KnockBack Code
    if (knockBackLeft){
        knockTimer ++;
        curKBSpeed -= fric;
        if (knockTimer &lt; 10){
            x += -(curKBSpeed);
        }else{
            knockBackLeft = 0;
            curKBSpeed = knockBackSpeed;    
        }    
    }
    if (knockBackRight){
        knockTimer ++;
        curKBSpeed -= fric;
        if (knockTimer &lt; 10){
            x  += (curKBSpeed);
        }else{
            knockBackRight = 0;
            curKBSpeed = knockBackSpeed;  
        }    
    }
    //Checks to see if the enemy is not being knocked back and if the state is walking(if so the walk forward)
    if (!knockBackRight &amp;&amp; !knockBackLeft &amp;&amp; state == 'walking'){
        x += walkSpeed;
    } 
    // Checks to see if the enemy is not being knocked back, if so then start attacking
    if (!knockBackRight &amp;&amp; !knockBackLeft &amp;&amp; state == 'attacking'){
        if (!madeContact){
            if (!jumpAttack){
                x += runSpeed; 
            }else{
                if (minerDist &lt; 80 &amp;&amp; minerDist &gt; 40){
                    jumping = 1;
                }else{
                    x += runSpeed;
                }
            } 
            //Makes the enemy jump(if the enemy has a jump attack)
            if (jumping){
                jumpTimer ++;
                if (jumpTimer &lt; 20){
                    x += runSpeed+1.5;
                    y -= 1.5;
                    gravity = .1;
                }
                if (jumpTimer &gt;= 15){
                    jumping = 0;
                    gravity = 0;
                    
                }
            } 
        }else{
            // Sets the enemy's sprite facing the right way
            if (contactTarget.x &gt; x){
                sprite_index = spriteAttackingRight;
            }else{
                sprite_index = spriteAttackingLeft;
            }
            attackTimer ++;
            if (attackTimer &gt;= 20){
                image_speed = .08;
            }
            if (attackTimer &gt;= 50){
                x += 1.5;
                if (attackTimer &gt;= 60){
                    attackTimer = 0;
                    image_speed = 0;
                    image_index = 0;
                }
            }
        }
        //Checks to see if the enemy is colliding with the ground or not.
        if (position_meeting(x,y+10,obj_solidGround)){
            gravity = 0;
            vspeed = 0;
        }
    }  
}else{
    image_speed = 0;
    image_alpha -= .01;
    if (image_alpha &lt;= 0){
        instance_destroy();
    }
}



</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_workerParent">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
madeContact = 1;
contactTarget = other.id;
jumping = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
part_system_destroy(global.partEnemyBlood);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>16,8</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
